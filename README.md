# Azure Api Management policy toolkit

**Azure api management policy toolkit** is a set of libraries and tools for **Azure Api Management** which target **policy document**. The toolkit was design to **help manage** and **test** policy documents with complex expressions.

## Quick start

### Prerequisite
Download and install [dotnet](https://dotnet.microsoft.com/en-us/download) according to instructions.

### Install dotnet tool

Create project folder and install dotnet console tool in it

```bash
dotnet tool install Mielek.Transformer
```

### Create simple policy builder script

Create a file with the name `global-document.csx`. Copy and paste the code snipped.

```csharp
return PolicyDocumentBuilder
    .Create()
    .Inbound(policies =>
    {
        policies.SetHeader(policy =>
        {
            policy
                .Name("X-Deployment-Region")
                .ExistAction(ExistAction.Override)
                .Value(context => context.Deployment.Region)
        })
    })
    .Build();
```
### Generate XML document

Invoke transformer tool to generate policy document 

```bash
dotnet policy-transformer
```

Tool will create the `target` folder. In the folder you will find the `global-document.xml` file with was generated by the tool. The content should look like the following snipped.

```xml
<policies>
    <inbound>
        <set-header name="X-Deployment-Region" exist-action="override">
            <value>@(context.Deployment.Region)</value>
        </set-header>
    </inbound>
    <backend />
    <outbound />
    <on-error />
</policies>
```

## Using external expression files

### Create expression file 

Create `expressions` folder and create `expression.csx` file  there. Fill the file with the content below.

```csharp
var response = context.Response.Body.As<JObject>();
foreach (var key in new[] { "current", "minutely", "hourly", "daily", "alerts" })
{
    response.Property(key)?.Remove();
};
return response.ToString();
```
### Link expression with policy

Add outbound policy section to `global-document.csx` builder script with the `SetBody` policy. Use `expression.csx` file for the `Body` property of the policy.

```csharp
return PolicyDocumentBuilder
    .Create()
    .Inbound(policies =>
    {
        policies.SetHeader(policy =>
        {
            policy
                .Name("X-Deployment-Region")
                .ExistAction(ExistAction.Override)
                .Value(context => context.Deployment.Region)
        })
    })
    .Outbound(policies => policies.SetBody(policy => policy.Body(expression => expression.FromFile("./expressions/expression.csx"))))
    .Build();
```

### Generate XML file with inlined expression

Invoke transformer tool to regenerate policy document 

```bash
dotnet policy-transformer
```

The `global-document.xml` should contain outbound section with content of expression script. 

```xml
<policies>
  <inbound>
    <set-header name="X-Deployment-Region" exist-action="override">
      <value>@(context.Deployment.Region)</value>
    </set-header>
  </inbound>
  <backend />
  <outbound>
    <set-body>@{
var response = context.Response.Body.As&lt;JObject&gt;();
foreach (var key in new[] { "current", "minutely", "hourly", "daily", "alerts" })
{
    response.Property(key)?.Remove();
};
return response.ToString();
}</set-body>
  </outbound>
  <on-error />
</policies>
```

## Testing script expressions

Create new test project

```bash
mkdir test
cd test
dotnet new mstest
```

Add expression testing library dependency

```bash
dotnet add Mielek.Testing.Expressions
```

Create new test class with content
```csharp
using Mielek.Testing.Expressions;
using Mielek.Testing.Expressions.Mocks;

[TestClass]
public class ExpressionTest
{
    [TestMethod]
    public async Task Test()
    {
        var expression = ExpressionProvider.LoadFromFile("./<PATH_TO_SCRIPT>/expression.csx");
        var context = new MockContext();
        context.MockResponse.MockBody.Content = "{ \"current\": \"some current content\", \"other\": \"some other content\" }";

        var result = await expression.Execute(context);

        var actual = JObject.Parse(result);
        var expected = JObject.Parse("{ \"other\": \"some other content\" }");

        Assert.IsTrue(JObject.DeepEquals(actual, expected));
    }
}
```

Now you can easily test your expression with the `dotnet test` command.

## Example project repository

Go to [example project](example) for further guidance.

## Contributing

Please refer to [CONTRIBUTION](CONTRIBUTION.md) file for contribution guidance.
